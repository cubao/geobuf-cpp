from __future__ import annotations
import numpy
import pybind11_stubgen.typing_ext
import typing
from . import geojson
from . import tf
__all__ = ['Decoder', 'Encoder', 'GeobufIndex', 'NodeItem', 'PackedRTree', 'Planet', 'geojson', 'is_subset_of', 'normalize_json', 'pbf_decode', 'rapidjson', 'str2geojson2str', 'str2json2str', 'tf']
class Decoder:
    def __init__(self) -> None:
        ...
    @typing.overload
    def decode(self, geobuf: str, *, indent: bool = False, sort_keys: bool = False) -> str:
        ...
    @typing.overload
    def decode(self, *, geobuf: str, geojson: str, indent: bool = False, sort_keys: bool = False) -> bool:
        ...
    def decode_feature(self, bytes: str, only_geometry: bool = False, only_properties: bool = False) -> ... | None:
        ...
    def decode_header(self, bytes: str) -> None:
        ...
    def decode_non_features(self, arg0: str) -> ...:
        ...
    def decode_to_geojson(self, geobuf: str) -> ...:
        ...
    def decode_to_rapidjson(self, geobuf: str, *, sort_keys: bool = False) -> ...:
        ...
    def dim(self) -> int:
        ...
    def keys(self) -> list[str]:
        ...
    def offsets(self) -> list[int]:
        ...
    def precision(self) -> int:
        ...
class Encoder:
    def __init__(self, *, max_precision: int = 1000000, only_xy: bool = False, round_z: int | None = None) -> None:
        ...
    def dim(self) -> int:
        ...
    def e(self) -> int:
        ...
    @typing.overload
    def encode(self, geojson: ..., std: ..., mapbox: ..., mapbox: ..., std: ...) -> bytes:
        ...
    @typing.overload
    def encode(self, features: ..., std: ...) -> bytes:
        ...
    @typing.overload
    def encode(self, feature: ...) -> bytes:
        ...
    @typing.overload
    def encode(self, geometry: ..., std: ...) -> bytes:
        ...
    @typing.overload
    def encode(self, geojson: ..., rapidjson: ...) -> bytes:
        ...
    @typing.overload
    def encode(self, geojson: typing.Any) -> bytes:
        ...
    @typing.overload
    def encode(self, *, geojson: str, geobuf: str) -> bool:
        ...
    @typing.overload
    def keys(self) -> dict[str, int]:
        ...
    @typing.overload
    def keys(self) -> dict[str, int]:
        ...
    def max_precision(self) -> int:
        ...
    def only_xy(self) -> bool:
        ...
    def round_z(self) -> float | None:
        ...
class GeobufIndex:
    @staticmethod
    def indexing(input_geobuf_path: str, output_index_path: str, *, feature_id: str | None = '@', packed_rtree: str | None = '@') -> bool:
        ...
    def __init__(self) -> None:
        ...
    @typing.overload
    def decode_feature(self, index: int, *, only_geometry: bool = False, only_properties: bool = False) -> geojson.Feature | None:
        ...
    @typing.overload
    def decode_feature(self, bytes: str, *, only_geometry: bool = False, only_properties: bool = False) -> geojson.Feature | None:
        ...
    def decode_feature_of_id(self, id: str, *, only_geometry: bool = False, only_properties: bool = False) -> geojson.Feature | None:
        ...
    def decode_features(self, index: list[int], *, only_geometry: bool = False, only_properties: bool = False) -> geojson.FeatureCollection:
        ...
    @typing.overload
    def decode_non_features(self, bytes: str) -> geojson.value:
        ...
    @typing.overload
    def decode_non_features(self) -> geojson.value:
        ...
    def init(self, index_bytes: str) -> bool:
        ...
    def mmap_bytes(self, offset: int, length: int) -> bytes | None:
        ...
    @typing.overload
    def mmap_init(self, index_path: str, geobuf_path: str) -> bool:
        ...
    @typing.overload
    def mmap_init(self, geobuf_path: str) -> bool:
        ...
    def query(self, arg0: numpy.ndarray[numpy.float64[2, 1]], arg1: numpy.ndarray[numpy.float64[2, 1]]) -> set[int]:
        ...
    @property
    def header_size(self) -> int:
        ...
    @property
    def ids(self) -> dict[str, int] | None:
        ...
    @property
    def num_features(self) -> int:
        ...
    @property
    def offsets(self) -> list[int]:
        ...
    @property
    def packed_rtree(self) -> PackedRTree:
        ...
class NodeItem:
    __hash__: typing.ClassVar[None] = None
    def __eq__(self, arg0: NodeItem) -> bool:
        ...
    def __ne__(self, arg0: NodeItem) -> bool:
        ...
    def expand(self, other: NodeItem) -> NodeItem:
        ...
    def intersects(self, other: NodeItem) -> bool:
        ...
    def to_numpy(self) -> numpy.ndarray[numpy.float64[4, 1]]:
        ...
    @property
    def height(self) -> float:
        ...
    @property
    def max_x(self) -> float:
        ...
    @property
    def max_y(self) -> float:
        ...
    @property
    def min_x(self) -> float:
        ...
    @property
    def min_y(self) -> float:
        ...
    @property
    def offset(self) -> int:
        ...
    @property
    def width(self) -> float:
        ...
class PackedRTree:
    def search(self, min_x: float, min_y: float, max_x: float, max_y: float) -> list[int]:
        ...
    @property
    def extent(self) -> numpy.ndarray[numpy.float64[4, 1]]:
        ...
    @property
    def node_size(self) -> int:
        ...
    @property
    def num_items(self) -> int:
        ...
    @property
    def num_nodes(self) -> int:
        ...
    @property
    def size(self) -> int:
        ...
class Planet:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: geojson.FeatureCollection) -> None:
        ...
    def build(self, *, per_line_segment: bool = False, force: bool = False) -> None:
        ...
    def copy(self, arg0: numpy.ndarray[numpy.int32[m, 1]]) -> geojson.FeatureCollection:
        ...
    def crop(self, polygon: numpy.ndarray[numpy.float64[m, 2], numpy.ndarray.flags.c_contiguous], *, clipping_mode: str = 'longest', strip_properties: bool = False, is_wgs84: bool = True) -> geojson.FeatureCollection:
        ...
    @typing.overload
    def features(self) -> geojson.FeatureCollection:
        ...
    @typing.overload
    def features(self, arg0: geojson.FeatureCollection) -> Planet:
        ...
    def packed_rtree(self) -> PackedRTree:
        ...
    def query(self, min: numpy.ndarray[numpy.float64[2, 1]], max: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.int32[m, 1]]:
        ...
class rapidjson:
    class type:
        """
        Members:

          kNullType

          kFalseType

          kTrueType

          kObjectType

          kArrayType

          kStringType

          kNumberType
        """
        __members__: typing.ClassVar[dict[str, rapidjson.type]]  # value = {'kNullType': <type.kNullType: 0>, 'kFalseType': <type.kFalseType: 1>, 'kTrueType': <type.kTrueType: 2>, 'kObjectType': <type.kObjectType: 3>, 'kArrayType': <type.kArrayType: 4>, 'kStringType': <type.kStringType: 5>, 'kNumberType': <type.kNumberType: 6>}
        kArrayType: typing.ClassVar[rapidjson.type]  # value = <type.kArrayType: 4>
        kFalseType: typing.ClassVar[rapidjson.type]  # value = <type.kFalseType: 1>
        kNullType: typing.ClassVar[rapidjson.type]  # value = <type.kNullType: 0>
        kNumberType: typing.ClassVar[rapidjson.type]  # value = <type.kNumberType: 6>
        kObjectType: typing.ClassVar[rapidjson.type]  # value = <type.kObjectType: 3>
        kStringType: typing.ClassVar[rapidjson.type]  # value = <type.kStringType: 5>
        kTrueType: typing.ClassVar[rapidjson.type]  # value = <type.kTrueType: 2>
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    __hash__: typing.ClassVar[None] = None
    kArrayType: typing.ClassVar[rapidjson.type]  # value = <type.kArrayType: 4>
    kFalseType: typing.ClassVar[rapidjson.type]  # value = <type.kFalseType: 1>
    kNullType: typing.ClassVar[rapidjson.type]  # value = <type.kNullType: 0>
    kNumberType: typing.ClassVar[rapidjson.type]  # value = <type.kNumberType: 6>
    kObjectType: typing.ClassVar[rapidjson.type]  # value = <type.kObjectType: 3>
    kStringType: typing.ClassVar[rapidjson.type]  # value = <type.kStringType: 5>
    kTrueType: typing.ClassVar[rapidjson.type]  # value = <type.kTrueType: 2>
    def Empty(self) -> bool:
        ...
    def Get(self) -> typing.Any:
        ...
    def GetBool(self) -> bool:
        ...
    def GetDouble(self) -> float:
        ...
    def GetFloat(self) -> float:
        ...
    def GetInt(self) -> int:
        ...
    def GetInt64(self) -> int:
        ...
    def GetRawString(self) -> memoryview:
        ...
    def GetString(self) -> str:
        ...
    def GetStringLength(self) -> int:
        ...
    def GetType(self) -> ...:
        ...
    def GetUInt64(self) -> int:
        ...
    def GetUint(self) -> int:
        ...
    def HasMember(self, arg0: str) -> bool:
        ...
    def IsArray(self) -> bool:
        ...
    def IsBool(self) -> bool:
        ...
    def IsDouble(self) -> bool:
        ...
    def IsFalse(self) -> bool:
        ...
    def IsFloat(self) -> bool:
        ...
    def IsInt(self) -> bool:
        ...
    def IsInt64(self) -> bool:
        ...
    def IsLosslessDouble(self) -> bool:
        ...
    def IsLosslessFloat(self) -> bool:
        ...
    def IsNull(self) -> bool:
        ...
    def IsNumber(self) -> bool:
        ...
    def IsObject(self) -> bool:
        ...
    def IsString(self) -> bool:
        ...
    def IsTrue(self) -> bool:
        ...
    def IsUint(self) -> bool:
        ...
    def IsUint64(self) -> bool:
        ...
    def SetArray(self) -> rapidjson:
        ...
    def SetDouble(self, arg0: float) -> rapidjson:
        ...
    def SetFloat(self, arg0: float) -> rapidjson:
        ...
    def SetInt(self, arg0: int) -> rapidjson:
        ...
    def SetInt64(self, arg0: int) -> rapidjson:
        ...
    def SetNull(self) -> rapidjson:
        ...
    def SetObject(self) -> rapidjson:
        ...
    def SetUint(self, arg0: int) -> rapidjson:
        ...
    def SetUint64(self, arg0: int) -> rapidjson:
        ...
    def Size(self) -> int:
        ...
    def __bool__(self) -> bool:
        ...
    def __call__(self) -> typing.Any:
        ...
    def __contains__(self, arg0: str) -> bool:
        ...
    def __copy__(self, arg0: dict) -> rapidjson:
        ...
    def __deepcopy__(self, memo: dict) -> rapidjson:
        ...
    @typing.overload
    def __delitem__(self, arg0: str) -> bool:
        ...
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        ...
    def __eq__(self, arg0: rapidjson) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: str) -> rapidjson:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> rapidjson:
        ...
    def __getstate__(self) -> typing.Any:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __ne__(self, arg0: rapidjson) -> bool:
        ...
    @typing.overload
    def __setitem__(self, index: int, value: typing.Any) -> typing.Any:
        ...
    @typing.overload
    def __setitem__(self, arg0: str, arg1: typing.Any) -> typing.Any:
        ...
    def __setstate__(self, arg0: typing.Any) -> None:
        ...
    def clear(self) -> rapidjson:
        ...
    def clone(self) -> rapidjson:
        ...
    def copy_from(self, arg0: rapidjson) -> rapidjson:
        ...
    def denoise_double_0(self) -> rapidjson:
        ...
    def dump(self, path: str, *, indent: bool = False, sort_keys: bool = False) -> bool:
        ...
    def dumps(self, *, indent: bool = False, sort_keys: bool = False) -> str:
        ...
    def get(self, key: str) -> rapidjson:
        ...
    def is_subset_of(self, other: rapidjson) -> bool:
        ...
    def keys(self) -> list[str]:
        ...
    def load(self, arg0: str) -> rapidjson:
        ...
    def loads(self, arg0: str) -> rapidjson:
        ...
    def locate_nan_inf(self) -> str | None:
        ...
    def normalize(self, *, sort_keys: bool = True, strip_geometry_z_0: bool = True, round_geojson_non_geometry: int | None = 3, round_geojson_geometry: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)] | None = [8, 8, 3], denoise_double_0: bool = True) -> rapidjson:
        ...
    def pop_back(self) -> rapidjson:
        ...
    def push_back(self, arg0: typing.Any) -> rapidjson:
        ...
    def round(self, *, precision: float = 3, depth: int = 32, skip_keys: list[str] = []) -> rapidjson:
        ...
    def round_geojson_geometry(self, *, precision: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)] = [8, 8, 3]) -> rapidjson:
        ...
    def round_geojson_non_geometry(self, *, precision: int = 3) -> rapidjson:
        ...
    @typing.overload
    def set(self, arg0: typing.Any) -> rapidjson:
        ...
    @typing.overload
    def set(self, arg0: rapidjson) -> rapidjson:
        ...
    def sort_keys(self) -> rapidjson:
        ...
    def strip_geometry_z_0(self) -> rapidjson:
        ...
    def values(self) -> list[rapidjson]:
        ...
def is_subset_of(path1: str, path2: str) -> bool:
    ...
@typing.overload
def normalize_json(input_path: str, output_path: str, *, indent: bool = True, sort_keys: bool = True, denoise_double_0: bool = True, strip_geometry_z_0: bool = True, round_non_geojson: int | None = 3, round_geojson_non_geometry: int | None = 3, round_geojson_geometry: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)] | None = [8, 8, 3]) -> bool:
    ...
@typing.overload
def normalize_json(json: ..., rapidjson: ..., *, sort_keys: bool = True, denoise_double_0: bool = True, strip_geometry_z_0: bool = True, round_non_geojson: int | None = 3, round_geojson_non_geometry: int | None = 3, round_geojson_geometry: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)] | None = [8, 8, 3]) -> ...:
    ...
def pbf_decode(pbf_bytes: str, *, indent: str = '') -> str:
    ...
def str2geojson2str(json_string: str, *, indent: bool = False, sort_keys: bool = False) -> str | None:
    ...
def str2json2str(json_string: str, *, indent: bool = False, sort_keys: bool = False) -> str | None:
    ...
__version__: str = '0.2.2'
